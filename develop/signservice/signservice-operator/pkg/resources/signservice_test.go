//
// Copyright 2020 IBM Corporation
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

package resources

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"reflect"
	"strings"
	"testing"

	"github.com/ghodss/yaml"
	"github.com/google/go-cmp/cmp"

	// yamlalt "github.com/goccy/go-yaml"

	researchv1alpha1 "github.com/IBM/integrity-enforcer/develop/signservice/signservice-operator/pkg/apis/research/v1alpha1"
	"github.com/IBM/integrity-enforcer/enforcer/pkg/mapnode"
)

func testObjAndYaml(t *testing.T, obj interface{}, yamlPath string) {

	// err := writeOnFile(yamlPath, obj)
	// if err != nil {
	// 	t.Errorf(err.Error())
	// 	return
	// }

	builtJsonB, _ := json.Marshal(obj)
	builtNode, err := mapnode.NewFromBytes(builtJsonB)
	if err != nil {
		t.Errorf(err.Error())
		return
	}

	goodYamlB, err := ioutil.ReadFile(yamlPath)
	if err != nil {
		t.Errorf(err.Error())
		return
	}

	goodNode, err := mapnode.NewFromYamlBytes(goodYamlB)
	if err != nil {
		t.Errorf(err.Error())
		return
	}

	if builtNode == nil {
		t.Errorf("buildNode is nil")
		return
	}

	if goodNode == nil {
		t.Errorf("goodNode is nil")
		return
	}

	dr := builtNode.Diff(goodNode)
	if dr != nil && dr.Size() > 0 {
		t.Errorf("Diff found between yaml generated by Go-operator and by Helm")
		for _, d := range dr.Items {
			t.Errorf(fmt.Sprintf("%s", d))
			before := d.Values["before"]
			after := d.Values["after"]
			if before != nil && reflect.TypeOf(before).Kind() == reflect.String {
				beforeStr := before.(string)
				afterStr := ""
				if after != nil {
					afterStr = after.(string)
				}
				diffstr := cmp.Diff(strings.Split(beforeStr, "\n"), strings.Split(afterStr, "\n"))
				t.Errorf(fmt.Sprintf("\tdetail: %s", diffstr))
			}
		}
	}
}

func loadTestSignServiceCR(t *testing.T) *researchv1alpha1.SignService {
	crBytes, err := ioutil.ReadFile("./testdata/test_signservice_cr.yaml")
	if err != nil {
		t.Errorf(err.Error())
	}
	var instance *researchv1alpha1.SignService
	err = yaml.Unmarshal(crBytes, &instance)
	if err != nil {
		t.Errorf(err.Error())
	}

	// err = writeOnFile("./testdata/test_signservice_cr_gen.yaml", instance)
	// if err != nil {
	// 	t.Errorf(err.Error())
	// }

	instance.Namespace = "testns"

	return instance
}

//cr
// func TestSignServiceKeyringSecret(t *testing.T) {
// 	instance := loadTestSignServiceCR(t)
// 	obj := BuildKeyringSecretForIE(instance)
// 	yamlPath := "./testdata/signservice_keyring.yaml"
// 	testObjAndYaml(t, obj, yamlPath)
// }

// func TestSignServicePrivateKeyringSecret(t *testing.T) {
// 	instance := loadTestSignServiceCR(t)
// 	obj := BuildPrivateKeyringSecretForIE(instance)
// 	yamlPath := "./testdata/signservice_private_keyring.yaml"
// 	testObjAndYaml(t, obj, yamlPath)
// }

func TestSingServiceServerCertSecret(t *testing.T) {
	instance := loadTestSignServiceCR(t)
	obj := BuildServerCertSecretForIE(instance)
	yamlPath := "./testdata/signservice_server_cert_secret.yaml"
	testObjAndYaml(t, obj, yamlPath)
}

func TestSingServiceServerDeployment(t *testing.T) {
	instance := loadTestSignServiceCR(t)
	obj := BuildSignServiceDeploymentForCR(instance)
	yamlPath := "./testdata/signservice_deployment.yaml"
	testObjAndYaml(t, obj, yamlPath)
}

func TestSingServiceServerService(t *testing.T) {
	instance := loadTestSignServiceCR(t)
	obj := BuildSignServiceServiceForCR(instance)
	yamlPath := "./testdata/signservice_service.yaml"
	testObjAndYaml(t, obj, yamlPath)
}
