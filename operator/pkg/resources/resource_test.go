//
// Copyright 2020 IBM Corporation
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//

package resources

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"os"
	"reflect"
	"strings"
	"testing"

	"github.com/ghodss/yaml"
	// yamlalt "github.com/goccy/go-yaml"

	"github.com/IBM/integrity-enforcer/enforcer/pkg/mapnode"
	researchv1alpha1 "github.com/IBM/integrity-enforcer/operator/pkg/apis/research/v1alpha1"
	"github.com/google/go-cmp/cmp"
)

func loadTestInstance(t *testing.T) *researchv1alpha1.IntegrityEnforcer {
	crBytes, err := ioutil.ReadFile("./testdata/test_cr.yaml")
	if err != nil {
		t.Errorf(err.Error())
	}
	var instance *researchv1alpha1.IntegrityEnforcer
	err = yaml.Unmarshal(crBytes, &instance)
	if err != nil {
		t.Errorf(err.Error())
	}

	// err = writeOnFile("./testdata/test_cr_gen.yaml", instance)
	// if err != nil {
	// 	t.Errorf(err.Error())
	// }

	instance.Namespace = "testns"

	return instance
}

func writeOnFile(fileName string, data interface{}) error {
	buf, err := yaml.Marshal(data)
	if err != nil {
		return err
	}
	err = ioutil.WriteFile(fileName, buf, os.ModePerm)
	if err != nil {
		return err
	}
	return nil
}

func testObjAndYaml(t *testing.T, obj interface{}, yamlPath string) {

	// err := writeOnFile(yamlPath, obj)
	// if err != nil {
	// 	t.Errorf(err.Error())
	// 	return
	// }

	builtJsonB, _ := json.Marshal(obj)
	builtNode, err := mapnode.NewFromBytes(builtJsonB)
	if err != nil {
		t.Errorf(err.Error())
		return
	}

	goodYamlB, err := ioutil.ReadFile(yamlPath)
	if err != nil {
		t.Errorf(err.Error())
		return
	}

	goodNode, err := mapnode.NewFromYamlBytes(goodYamlB)
	if err != nil {
		t.Errorf(err.Error())
		return
	}

	if builtNode == nil {
		t.Errorf("buildNode is nil")
		return
	}

	if goodNode == nil {
		t.Errorf("goodNode is nil")
		return
	}

	dr := builtNode.Diff(goodNode)
	if dr != nil && dr.Size() > 0 {
		t.Errorf("Diff found between yaml generated by Go-operator and by Helm")
		for _, d := range dr.Items {
			t.Errorf(fmt.Sprintf("%s", d))
			before := d.Values["before"]
			after := d.Values["after"]
			if before != nil && reflect.TypeOf(before).Kind() == reflect.String {
				beforeStr := before.(string)
				afterStr := ""
				if after != nil {
					afterStr = after.(string)
				}
				diffstr := cmp.Diff(strings.Split(beforeStr, "\n"), strings.Split(afterStr, "\n"))
				t.Errorf(fmt.Sprintf("\tdetail: %s", diffstr))
			}
		}
	}
}

//cr
func TestEnforcerConfigCR(t *testing.T) {
	instance := loadTestInstance(t)
	obj := BuildEnforcerConfigForIE(instance)
	yamlPath := "./testdata/enforcerConfigCR.yaml"
	testObjAndYaml(t, obj, yamlPath)
}

// func TestEnforcePolicyCR(t *testing.T) {
// 	instance := loadTestInstance(t)
// 	obj := BuildDefaultEnforcePolicyForIE(instance)
// 	yamlPath := "./testdata/enforcePolicyCR.yaml"
// 	testObjAndYaml(t, obj, yamlPath)
// }

func TestResourceSignatureCR(t *testing.T) {
	instance := loadTestInstance(t)
	obj := BuildResourceSignatureForCR(instance)
	yamlPath := "./testdata/resourceSignatureCR.yaml"
	testObjAndYaml(t, obj, yamlPath)
}

//crd
func TestEnforcerConfigCRD(t *testing.T) {
	instance := loadTestInstance(t)
	obj := BuildEnforcerConfigCRD(instance)
	yamlPath := "./testdata/enforcerConfigCRD.yaml"
	testObjAndYaml(t, obj, yamlPath)
}

func TestResourceSignatureCRD(t *testing.T) {
	instance := loadTestInstance(t)
	obj := BuildResourceSignatureCRD(instance)
	yamlPath := "./testdata/resourceSignatureCRD.yaml"
	testObjAndYaml(t, obj, yamlPath)
}

//deploy

func TestDeployment(t *testing.T) {
	instance := loadTestInstance(t)
	obj := BuildDeploymentForCR(instance)
	yamlPath := "./testdata/deployment.yaml"
	testObjAndYaml(t, obj, yamlPath)
}

//role
func TestSecurityContextConstraints(t *testing.T) {
	instance := loadTestInstance(t)
	obj := BuildSecurityContextConstraints(instance)
	yamlPath := "./testdata/securityContextConstraints.yaml"
	testObjAndYaml(t, obj, yamlPath)
}

func TestServiceAccount(t *testing.T) {
	instance := loadTestInstance(t)
	obj := BuildServiceAccountForIE(instance)
	yamlPath := "./testdata/serviceAccount.yaml"
	testObjAndYaml(t, obj, yamlPath)
}

func TestClusterRole(t *testing.T) {
	instance := loadTestInstance(t)
	obj := BuildClusterRoleForIE(instance)
	yamlPath := "./testdata/clusterRole.yaml"
	testObjAndYaml(t, obj, yamlPath)
}

func TestClusterRoleBinding(t *testing.T) {
	instance := loadTestInstance(t)
	obj := BuildClusterRoleBindingForIE(instance)
	yamlPath := "./testdata/clusterRoleBinding.yaml"
	testObjAndYaml(t, obj, yamlPath)
}

func TestPodSecurityPolicy(t *testing.T) {
	instance := loadTestInstance(t)
	obj := BuildPodSecurityPolicy(instance)
	yamlPath := "./testdata/podSecurityPolicy.yaml"
	testObjAndYaml(t, obj, yamlPath)
}

//secret
func TestRegKeySecret(t *testing.T) {
	instance := loadTestInstance(t)
	obj := BuildRegKeySecretForCR(instance)
	yamlPath := "./testdata/regKeySecret.yaml"
	testObjAndYaml(t, obj, yamlPath)
}

func TestTlsSecret(t *testing.T) {
	instance := loadTestInstance(t)
	obj := BuildTlsSecretForIE(instance)
	yamlPath := "./testdata/tlsSecret.yaml"
	testObjAndYaml(t, obj, yamlPath)
}

///webhook
func TestService(t *testing.T) {
	instance := loadTestInstance(t)
	obj := BuildServiceForCR(instance)
	yamlPath := "./testdata/service.yaml"
	testObjAndYaml(t, obj, yamlPath)
}

func TestMutatingWebhookConfiguration(t *testing.T) {
	instance := loadTestInstance(t)
	obj := BuildMutatingWebhookConfigurationForIE(instance)
	yamlPath := "./testdata/mutatingWebhookConfiguration.yaml"
	testObjAndYaml(t, obj, yamlPath)
}
